---
layout: post
title:  "Linux Command Line for Bioinformatics"
author: at
categories: [ virome, tutorial, metaphage ]
image: assets/images/code.jpg
hidden: false
---

## What you need

* A computer with a Linux compatible terminal, this means:
  * any **MacBook** or Mac computer with a recent version of MacOS (recommended)
  * a **Linux** machine (Ubuntu and its variants are recommended)
  * a Windows computer with [Windows Subsystem for Linux](https://docs.microsoft.com/en-us/windows/wsl/install-win10) installed (unsupported, sorry)

## A first look

Open the Terminal emulator (on a Mac it is called "Terminal", on Linux it is called "Terminal" or "GNOME Terminal").
You should see something like this:

![MacOS terminal]({{ site.baseurl }}/assets/images/terminal.png)

The terminal is a text-based interface to the computer. 
It is a program that takes commands from the keyboard and gives them to the computer's operating system to run.

The string `telatin@N121515:~$` (or similar) is called the **prompt**, and it's an indication the terminal is waiting for your input.
You can type a command (like `pwd` in the image above) and press `Enter` to execute it.
If the program returns some text, it will be printed after the prompt,
and when the program finishes the execution, you
will receive a new prompt.

:bulb: Try yourself, type `pwd` and press `Enter` to see what it does.

## First commands

We used `pwd` (*print working directory*) to see where we are in the file system, it will print the directory we are in.

Now let's try:

```bash
date
```

The first string you type after the terminaldate is the command, in this case is `date`. Most commands will 
give us the possibility to pass some parameters, to tune their output or to feed some input. 

For example, to get the current timestamp in UTC:

```bash
date -u
```

We call `-u` a switch (it's either on or off).

Date has a format string that we can use to get the output formatted exactly as we need, for example try:

```bash
date -u +"%Y-%m-%d"   
```

In UNIX, all commands are **case sensitive**, and most of the times they will be in lowercase.

## Navigating the file system

:warning: it is hard to believe it, but this is the most important part of the tutorial,
and one of the hardest to learn (it's not difficult, but it takes practice)

The file system is the way the computer organizes the files and directories (folders) on the disk.
You are used to see a graphical interface to navigate the file system, and it feels easier to use.

In UNIX systems, all the possible directories we have access to, are nested in a single root directory, called `/`.
The root directory is the top of the tree, and all the other directories are nested inside it.

![Hierarchical file system](https://raw.githubusercontent.com/telatin/learn_bash/41df5f439b13851ef3082641a116e29aa4a1dc31/files/tree.gif)

In the above scheme the directory *steve* is a subdirectory of *admin*, and *admin* is a subdirectory of *users*.

Every location (file or directory) in the file system can be described either:

* as an **absolute path**, that is the full path from the root directory to the location, for example `/users/admin/steve`
* or as a **relative path**, that is the path from the current directory to the location, so if we are inside *jon*, it would bee `../admin/steve`

Let's clarify these concepts:

* Absolute paths (almost) always start with `/`, and they are the same for everyone, no matter where they are in the file system.
  * Each absolute paths is crafted separating with slashes the names of the directories in the path. The final trailing slash (for direcrories) is optional, but it's wrong if the path is for a file.
  * `~` is a shortcut for the home directory of the current user, so if "Steve" is the active user `/users/admin/steve` can be written as `~`. When you want to refer to *your* home directory, you can use `~` (or `$HOME`). `~` is an absolute path too.
  * Example: `/users/admin/steve` is an absolute path for a directory, and equals to `/users/admin/steve/`
  * Example: `/users/admin/list.txt` is an absolute path for a file. 
* Relative paths never start with `/`, and they are different depending on where they are in the file system.
  * Your current directory is represented by the dot `.`. 
  * The parent directory is represented by `..`.
  * Example: `../../directory/file.txt` means that you want to access a file inside a directory that is two levels "above" your *current directory*.

Remember that if you don't know where you are, you can always use `pwd` to print the current directory (its output is an absolute path).

## pwd

We already mentioned that `pwd` prints the current directory.

## cd

To change our current directory we can use the `cd` (change directory) command. It takes an absolute or relative path as a parameter.

```bash
# String after a "#" are considered comments
cd /users/admin/steve

# This command will bring us one level up
cd ..
```

:bulb: if you don't specify a path, `cd` will bring you to your home directory. If you want to return to your previous directory, you can use `cd -`.

## ls

The `ls` command lists the contents of a directory or a set of files. It's a powerful command, and it has many options, but we will start with the basics.

```bash
ls
```

Some parameters it can take:

* One or more files (will print them). E. g. `ls file1.txt file2.txt`
* One or more directories (will print their contents). E. g. `ls ~/`
* `-l` is a switch to print the contents in a long format, with more information. E. g. `ls -l`
* `-h` is a switch to print the file sizes in a human readable format. E. g. `ls -h`
* Multiple switches can be combined. E. g. `ls -lh`

## mkdir

To create a new directory we can use the `mkdir` (make directory) command. It takes a path as a parameter.

```bash
# Try repeating the command twice!
mkdir new_dir

ls -l

# Let's try again, will this work?
mkdir new_dir
```

## rmdir

To remove a *empty* directory we can use the `rmdir` (remove directory) command. It takes a path as a parameter.

```bash
rmdir new_dir
```

## echo

The `echo` command prints its arguments back to the standard output. We will use this as a diagnostic tool.

```bash
echo "Hello world!"
```

It can be used to see the content of *variables*, for example:

```bash
echo My home is $HOME
```


